function run_petakit_cropper(json_file)
% RUN_PETAKIT_CROPPER High-performance parallel cropping replacement for opym.cli
%   Reads the JSON generated by the Jupyter notebook and executes
%   the crop on the MATLAB Parallel Pool (48+ cores).

    % 1. Parse the Job JSON
    if ~isfile(json_file)
        error('JSON file not found: %s', json_file);
    end

    % Read file content safely
    fid = fopen(json_file, 'r');
    raw = fread(fid, inf);
    str = char(raw');
    fclose(fid);
    job = jsondecode(str);

    inputFile = job.dataDir;
    [dataRoot, baseName, ~] = fileparts(inputFile);

    % Setup Output Directory
    outputDir = fullfile(dataRoot, [baseName, '_cropped']);
    if ~exist(outputDir, 'dir')
        mkdir(outputDir);
    end

    fprintf('üöÄ Starting Parallel Crop: %s\n', baseName);

    % 2. Parse Parameters
    % Convert Python 0-based ROIs (start:stop) to MATLAB 1-based (start+1:stop)
    top_roi = parse_roi_str(job.parameters.rois.top);
    bot_roi = parse_roi_str(job.parameters.rois.bottom);

    do_rotate = false;
    if isfield(job.parameters, 'rotate')
        do_rotate = job.parameters.rotate;
    end

    req_channels = [];
    if isfield(job.parameters, 'channels')
        req_channels = job.parameters.channels; % 0-based list
    end

    % 3. Analyze Input File (Fast Metadata Scan)
    if ~exist(inputFile, 'file')
        error('Input file not found: %s', inputFile);
    end

    % Use Tiff library to count frames
    t = Tiff(inputFile, 'r');

    % Try to determine channel count from OME-XML (ImageDescription)
    % This is crucial for splitting channels correctly.
    num_channels = 1;
    try
        desc = t.getTag('ImageDescription');
        % Look for SizeC="X"
        tokens = regexp(desc, 'SizeC="(\d+)"', 'tokens');
        if ~isempty(tokens)
            num_channels = str2double(tokens{1}{1});
        end
    catch
        warning('Could not parse OME-XML SizeC. Defaulting to 1 channel.');
    end

    % Count total directories (frames)
    % (Standard OME-TIFFs are flat lists of directories)
    num_total_dirs = 0;
    while true
        num_total_dirs = num_total_dirs + 1;
        if t.lastDirectory(), break; end
        t.nextDirectory();
    end
    t.close();

    % Safe worker count check
    pool = gcp('nocreate');
    if isempty(pool)
        n_workers = 1;
        fprintf('‚ö†Ô∏è No parallel pool found. Running serially.\n');
    else
        n_workers = pool.NumWorkers;
    end

    fprintf('üìä Metadata: %d Directories, %d Channels assumed.\n', num_total_dirs, num_channels);
    fprintf('üî• Launching parallel processing on %d workers...\n', n_workers);

    % 4. Execute Parallel Loop
    % We process every directory in the TIFF.
    % We assume standard OME-TIFF order: Interleaved Channels (C0, C1, C0, C1...)

    parfor k = 1:num_total_dirs
        % Turn off Tiff library warnings for clean logs
        warning('off', 'MATLAB:imagesci:Tiff:libraryWarning');

        % Calculate 0-based index and channel
        idx_0 = k - 1;
        c_idx = mod(idx_0, num_channels);

        % If specific channels were requested, skip unwanted ones
        if ~isempty(req_channels) && ~ismember(c_idx, req_channels)
            continue;
        end

        % Open Tiff locally on worker (Thread-safe)
        try
            lt = Tiff(inputFile, 'r');
            lt.setDirectory(k);
            img = lt.read();
            lt.close();
        catch
            continue; % Skip bad frames
        end

        % --- Channel Logic ---
        % Channels 0, 3 are typically Bottom Camera
        % Channels 1, 2 are typically Top Camera
        is_bot_channel = ismember(mod(c_idx, 4), [0, 3]);
        is_top_channel = ismember(mod(c_idx, 4), [1, 2]);

        % --- Process TOP ROI ---
        if ~isempty(top_roi) && is_top_channel
            % MATLAB ROI: [y_start, y_end, x_start, x_end]
            crop_t = img(top_roi(1):top_roi(2), top_roi(3):top_roi(4));

            if do_rotate
                crop_t = rot90(crop_t);
            end

            % Save: frame_XXXXXX_cXX_top.tif
            fName = sprintf('frame_%06d_c%02d_top.tif', k, c_idx);
            imwrite(crop_t, fullfile(outputDir, fName));
        end

        % --- Process BOTTOM ROI ---
        if ~isempty(bot_roi) && is_bot_channel
            crop_b = img(bot_roi(1):bot_roi(2), bot_roi(3):bot_roi(4));

            if do_rotate
                crop_b = rot90(crop_b);
            end

            fName = sprintf('frame_%06d_c%02d_bot.tif', k, c_idx);
            imwrite(crop_b, fullfile(outputDir, fName));
        end
    end

    fprintf('‚úÖ Parallel Crop Complete. Output in: %s\n', outputDir);
end

function roi = parse_roi_str(s)
    % Converts Python "y1:y2,x1:x2" string to MATLAB [y1, y2, x1, x2] indices
    % Python: 0-based, [start, end)
    % MATLAB: 1-based, [start, end]

    if isempty(s) || strcmp(s, 'null')
        roi = [];
        return;
    end

    % Replace ':' and ',' with spaces
    clean = replace(s, {':', ','}, ' ');
    vals = sscanf(clean, '%d %d %d %d');

    if numel(vals) == 4
        y1 = vals(1); y2 = vals(2);
        x1 = vals(3); x2 = vals(4);

        % Convert Logic:
        % Start_Mat = Start_Py + 1
        % End_Mat   = End_Py
        roi = [y1+1, y2, x1+1, x2];
    else
        roi = [];
    end
end
